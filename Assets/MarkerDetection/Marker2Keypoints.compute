// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float> Input;
float Threshold;
uint Width;
uint Height;
RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float I_p = Input[id.xy];
    
    // ignore points on the edge
    if (id.x < 3 || id.y < 3 || id.x >= Width-3 || id.y >= Height-3) {
        Result[id.xy] = float4(I_p,I_p,I_p,1);
        return;
    }

    //// Compute Keypoints using FAST n=12
    // Get intensities of 16 points on Bresenham circle of radius 3
    float I_n[16];
    I_n[0] = Input[uint2(id.x, id.y-3)];
    I_n[1] = Input[uint2(id.x+1, id.y-3)];
    I_n[2] = Input[uint2(id.x+2, id.y-2)];
    I_n[3] = Input[uint2(id.x+3, id.y-1)];
    I_n[4] = Input[uint2(id.x+3, id.y)];
    I_n[5] = Input[uint2(id.x+3, id.y+1)];
    I_n[6] = Input[uint2(id.x+2, id.y+2)];
    I_n[7] = Input[uint2(id.x+1, id.y+3)];
    I_n[8] = Input[uint2(id.x, id.y+3)];
    I_n[9] = Input[uint2(id.x-1, id.y+3)];
    I_n[10] = Input[uint2(id.x-2, id.y+2)];
    I_n[11] = Input[uint2(id.x-3, id.y+1)];
    I_n[12] = Input[uint2(id.x-3, id.y)];
    I_n[13] = Input[uint2(id.x-3, id.y-1)];
    I_n[14] = Input[uint2(id.x-2, id.y-2)];
    I_n[15] = Input[uint2(id.x-1, id.y-3)];
    
    // Calculate if circle points are above or below threshold
    int Dir_n[16];

    for (uint i1 = 0; i1 < 16; i1++) {
        if (I_n[i1] > I_p + Threshold) {
            Dir_n[i1] = 1;
        } else if (I_n[i1] < I_p - Threshold) {
            Dir_n[i1] = -1;
        } else {
            Dir_n[i1] = 0;
        }
    }
    
    // check if we have 12 contiguous points above or below the threshold
    int count = 0;
    for (uint i2 = 4; i2 < 16; i2++) {
        if (I_n[i2] > I_p + Threshold) {
            count++;
        } else if (I_n[i2] < I_p - Threshold) {
            count--;
        }
    }

    for (uint i = 0; i < 16; i++) {
        uint j = (i + 4) - (16 * ((i + 4)/ 16)); // mod

        if (I_n[i] > I_p + Threshold) {
            count++;
        } else if (I_n[i] < I_p - Threshold) {
            count--;
        }

        if (I_n[j] > I_p + Threshold) {
            count--;
        } else if (I_n[j] < I_p - Threshold) {
            count++;
        }
        if (count == 12 || count == -12) {
            Result[id.xy] = float4(1,0,0,1);
            return;
        }
    }

    Result[id.xy] = float4(I_p,I_p,I_p,1);
}
